{"version":3,"sources":["Visulalizer/Node.js","Visulalizer/Algorithms/dijkstra.js","Visulalizer/Algorithms/AStar.js","Visulalizer/Algorithms/dfs.js","Visulalizer/Algorithms/bfs.js","Visulalizer/Algorithms/gbs.js","Visulalizer/MazeAlgorithms/RandomDFS.js","Visulalizer/MazeAlgorithms/RecursiveDivision.js","Visulalizer/Visualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","isEnd","isStart","col","row","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","addedClass","id","className","React","Component","dijkstra","grid","startNode","endNode","i","f","Infinity","changeFtoInfinity","path","unvisitedNodes","nodes","j","push","getAllNodes","length","sort","n1","n2","nextNode","shift","isVisited","updateNeighbour","node","neighbours","filter","neighbour","getNeighbours","n","previous","getPath","cn","unshift","getH","node1","node2","Math","abs","traverse","visited","ns","includes","DFS","t","queue","current","walls","recursiveDivision","console","log","addOuterWalls","addInnerWalls","h","minX","maxX","minY","maxY","y","floor","randomNumber","hole","index","indexOf","splice","addHWall","x","addVWall","min","max","random","STARTNODE_i","STARTNODE_j","ENDNODE_i","ENDNODE_j","getGrid","width","height","newNode","distance","g","makeNewNode","ng","slice","toggleWall","makeStart","removeStart","makeEnd","removeEnd","Visualizer","state","mousePressed","startPicked","endPicked","message","showScores","algoIsRunning","setState","document","getElementById","innerHTML","shortPath","showScore","setTimeout","animateShortestPath","shortestPath","animate","open","closed","lowestIndex","currentNode","trackG","AStar","BFS","GBS","path1","path2","shortestPath1","shortestPath2","clear","stack","next","generateMazeRandomDFS","animateWalls","w","makeWalls","map","rowId","cell","cellId","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","App","currentAlgo","algoTypeWeighted","child","createRef","prevState","a","algo","e","preventDefault","clearAnimation","visualizeDijkstra","visualizeAStar","visualizeDFS","visualizeBFS","visualizeGBS","visualizeBidirectional","maze","visualizeRandomDFSMaze","visualizeRecursiveDivision","src","style","marginRight","alt","href","role","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","onClick","chageAlgo","createMaze","aria-label","marginTop","marginLeft","fontSize","border","borderRadius","type","changeShowScores","disabled","clearPath","Visualize","ref","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.19c0e017.chunk.js","sourcesContent":["import React from \"react\"\nimport \"./Node.css\"\n\nexport default class Node extends React.Component{\n    render(){\n        const {isEnd, isStart, col, row, isWall, onMouseDown, onMouseEnter, onMouseUp, onMouseLeave} = this.props\n        const addedClass = isStart ? \"node-start\" : isEnd ? \"node-end\" :isWall ? 'node-wall' : '';\n        return <td id = {`node-${row}-${col}`}\n                    className = {`node ${addedClass}`}\n                    onMouseDown = {()=>onMouseDown(row,col)}\n                    onMouseEnter = {() => onMouseEnter(row,col)}\n                    onMouseUp = {()=>onMouseUp(row,col)}\n                    onMouseLeave = {()=>onMouseLeave(row,col)}\n                    ></td>\n    }\n}\n\nexport const DEFAULT_NODE = {\n    row: 0,\n    col: 0,\n};","\n export function dijkstra(grid, startNode, endNode){\n    if (!startNode || !endNode || (startNode === endNode)){\n        return false;\n    }\n    changeFtoInfinity(grid)\n    const path = [];\n    startNode.f = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while(!!unvisitedNodes.length){\n        sortNodes(unvisitedNodes);\n        const nextNode = unvisitedNodes.shift();\n        if (nextNode.isWall) continue;\n        if (nextNode.f === Infinity) return -1;\n        nextNode.isVisited = true\n        path.push(nextNode)\n        if(nextNode === endNode) return path\n        updateNeighbour(nextNode, grid)\n    }\n     \n}\n\nfunction sortNodes(n){\n    n.sort((n1, n2) => n1.f - n2.f );\n}\n\nfunction updateNeighbour(node,grid) {\n    const neighbours = getNeighbours(node, grid);\n    for(const n of neighbours){\n        n.f = node.f + 1;\n        n.previous = node\n    }\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}\n\nfunction getAllNodes(grid){\n    const nodes = [];\n    for(let i of grid){\n        for(let j of i){\n            nodes.push(j);\n        }\n    }\n    return nodes;\n}\n\nfunction changeFtoInfinity(grid) {\n    for(let i of grid){\n        for(let j of i){\n            j.f = Infinity\n        }\n    }\n}\n\nexport function getPath(endNode) {\n    const path = []\n    let cn = endNode\n    while(cn !== null){\n        path.unshift(cn)\n        cn = cn.previous\n    }\n    return path\n}","export function AStar(grid,startNode,endNode) {\n    if (!startNode || !endNode || (startNode === endNode)){\n        return false;\n    }\n    const open = []\n    const closed = []\n    open.push(startNode);\n    while(true){\n        if(open.length > 0){\n            let lowestIndex = 0\n            for(let i = 0; i<open.length; i++){\n                if (open[i].f < open[lowestIndex].f){\n                    lowestIndex = i\n                }\n            }\n            const currentNode = open[lowestIndex]\n            if(currentNode === endNode){\n                return closed\n            }\n            closed.push(currentNode)\n            currentNode.isVisited = true\n            const index = open.indexOf(currentNode)\n            if(index>-1){\n                open.splice(index,1)\n            }\n            const neighbours = getNeighbours(currentNode, grid)\n            for(let n of neighbours){\n                if(!n.isWall && !(closed.includes(n))){\n                    const trackG = currentNode.g + 1\n                    if(open.includes(n)){\n                        if(n.g>trackG){\n                            n.h = getH(n, endNode)\n                            n.g = trackG\n                            n.f = n.g + n.h\n                        }\n                    }\n                    else{\n                        n.h = getH(n, endNode)\n                        n.g = trackG\n                        n.f = n.g + n.h\n                        open.push(n)\n                    }\n                    n.previous = currentNode\n                }\n            }\n\n        }\n        else{\n            return -1\n        }\n    }\n}\n\nfunction getH(node1,node2) {\n    let p =  Math.abs(node1.row - node2.row) + Math.abs(node1.col-node2.col)\n    return p\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}","\nfunction traverse(grid, startNode, visited){\n    visited.push(startNode)\n    const neighbours = getNeighbours(startNode, grid);\n    const ns = neighbours.filter(n=>!visited.includes(n))\n    for(let n of ns){\n        if(n.isWall){continue}\n        if(!n.isVisited){\n            n.previous = startNode;\n            n.isVisited = true\n            traverse(grid, n, visited);\n        }\n    }\n    return visited\n}\n\nexport function DFS(grid, startNode, endNode) {\n    startNode.isVisited = true\n    const nodes = traverse(grid, startNode,[])\n    const t = []\n    for(let n of nodes){\n        if(n===endNode){return t}\n        t.push(n)\n    }\n    return -1\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    \n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours);\n}","function traverse(grid, startNode) {\n    const queue = []\n    const visited = []\n    startNode.isVisited = true\n    queue.push(startNode)\n    while(queue.length>0){\n        const current = queue.shift()\n        visited.push(current)\n        const neighbours = getNeighbours(current, grid)\n        for(let n of neighbours){\n            if(!n.isVisited && !n.isWall){\n                queue.push(n)\n                n.previous = current\n                n.isVisited = true\n            }\n        }\n    }\n    return visited\n}\n\nexport function BFS(grid, startNode, endNode) {\n    const nodes = traverse(grid, startNode)\n    const t = []\n    for(let n of nodes){\n        if(n===endNode){return t}\n        t.push(n)\n    }\n    return -1\n}\nexport function BFS1(grid, startNode) {\n    const nodes = traverse(grid, startNode)\n    if(nodes) return nodes;\n    return -1\n}\n\nexport function Bidirectional(grid, startNode, endNode) {\n    const grid1 = grid.slice()\n    const grid2 = grid.slice()\n    const forward = traverse(grid1, startNode)\n    const backward = traverse(grid2, endNode)\n    console.log(backward)\n    // console.log(forward)\n    // console.log(backward)\n    // let intersection = []\n    // for(let f of forward){\n    //     backward.slice().reverse().forEach((b)=>{\n    //         if(f.row === b.row && f.col === b.col){\n    //             intersection[0] = f\n    //             intersection[1] = b\n    //             const path1 = forward.splice(0, forward.indexOf(intersection[0]))\n    //             const path2 = backward.splice(0, backward.indexOf(intersection[1]))\n    //             return [path1, path2, intersection]\n    //         }\n    //     })\n    // }\n    return -1\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}","\nexport function GBS(grid, startNode, endNode){\n    const queue = []\n    const visited = []\n    startNode.f = getH(startNode, endNode)\n    startNode.isVisited = true\n    queue.push(startNode)\n    while(queue.length > 0){\n        sortByCost(queue)\n        const currentNode = queue.shift()\n        \n        visited.push(currentNode)\n        if(currentNode === endNode){\n            return visited;}\n        const neighbours = getNeighbours(currentNode, grid)\n        for(let n of neighbours){\n            if(n.isWall) continue\n            queue.push(n)\n            n.f = getH(n, endNode)\n            n.previous = currentNode\n            n.isVisited = true\n            \n        }\n    }\n    return -1\n}\n\nfunction sortByCost(q) {\n    q.sort((n1,n2)=>n1.f - n2.f)\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}\n\nfunction getH(node1,node2) {\n    let p =  Math.abs(node1.row - node2.row) + Math.abs(node1.col-node2.col)\n    return p\n}","export function generateMazeRandomDFS(grid, startNode, endNode){\n    const walls = []\n    for(let i of grid){\n        for(let j of i){\n            if(j!==startNode&&j!==endNode){\n                j.isWall=true\n            }\n        }\n    }\n    let current = startNode\n    const stack = []\n    current.isVisited = true\n    while(true){\n        const neighbours = getNeighbours(current, grid)\n        if(neighbours.length > 0){\n            const r = Math.floor(Math.random()*neighbours.length)\n            const next = neighbours[r]\n            next.isVisited = true\n            if(next.row > current.row){\n                grid[current.row+1][current.col].isWall = false\n            }\n            else if(next.row < current.row){\n                grid[current.row-1][current.col].isWall = false\n            }\n            else if(next.col < current.col){\n                grid[current.row][current.col-1].isWall = false\n            }\n            else if(next.col > current.col){\n                grid[current.row][current.col+1].isWall = false\n            }\n            stack.push(current)\n            next.isWall = false\n            current = next\n        }\n        else if(stack.length > 0){\n            current = stack.shift()\n        }\n        else{\n            break\n        }\n\n    }\n\n    for(let i of grid){\n        for(let j of i){\n            if(j.isWall && !j.isStart && !j.isEnd){\n                walls.push(j)\n            }\n        }\n    }\n\n    return walls\n    \n}\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row-1>0){neighbours.push(grid[row-2][col])};\n    if(row+1<grid.length-1){neighbours.push(grid[row+2][col])};\n    if(col-1>0){neighbours.push(grid[row][col-2])};\n    if(col+1<grid[0].length-1){neighbours.push(grid[row][col+2])};\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}","let walls = []\nexport function recursiveDivision(grid) {\n    walls = []\n    console.log(grid)\n    addOuterWalls(grid)\n    addInnerWalls(grid, true, 1, grid[0].length-2, 1, grid.length-2)\n    return walls;\n}\n\nfunction addOuterWalls(grid) {\n    for(let i = 0; i<grid.length; i++){\n        if(i===0||i===grid.length-1){\n            for (let j = 0; j < grid[0].length; j++) {\n                if(!grid[i][j].isStart && !grid[i][j].isEnd){\n                    walls.push(grid[i][j])\n                    grid[i][j].isWall = true\n                }\n            }\n        }\n        else{\n            if(!grid[i][0].isStart && !grid[i][0].isEnd){\n                grid[i][0].isWall = true\n                walls.push(grid[i][0]);\n            }\n            if(!grid[i][grid[0].length - 1].isStart && !grid[i][grid[0].length - 1].isEnd){\n                grid[i][grid[0].length - 1].isWall = true\n                walls.push(grid[i][grid[0].length - 1]);\n            }\n        }\n    }\n}\nfunction addInnerWalls(grid,h, minX, maxX, minY, maxY) {\n    if(h){\n        if(maxX - minX<2){\n            return;\n        }\n        let y = Math.floor(randomNumber(minY, maxY)/2)*2;\n        addHWall(grid,minX,maxX,y);\n        addInnerWalls(grid,!h, minX, maxX, minY, y-1);\n        addInnerWalls(grid,!h, minX, maxX, y+1, maxY);\n    }\n    else{\n        if(maxY - minY<2){\n            return;\n        }\n        let x = Math.floor(randomNumber(minX, maxX)/2)*2;\n        addVWall(grid,minY,maxY,x)\n        addInnerWalls(grid,!h, minX, x-1, minY, maxY)\n        addInnerWalls(grid,!h, x+1, maxX, minY, maxY)\n    }\n}\n\nfunction addHWall(grid,minX, maxX, y) {\n    var hole = Math.floor(randomNumber(minX, maxX)/2)*2+1;\n    for(let i = minX ; i<=maxX; i++){\n        if(i===hole){\n            grid[y][i].isWall = false\n            if(walls.includes(grid[y][i])){\n                let index = walls.indexOf(grid[y][i])\n                walls.splice(index,1)\n            }\n        }else{\n            if(!grid[y][i].isStart && !grid[y][i].isEnd){\n                grid[y][i].isWall = true\n                walls.push(grid[y][i])\n            }\n        }\n    }\n}\nfunction addVWall(grid,minY, maxY, x) {\n    var hole = Math.floor(randomNumber(minY, maxY)/2)*2+1;\n    for(let i = minY ; i<=maxY; i++){\n        if(i===hole){\n            grid[i][x].isWall = false\n            if(walls.includes(grid[i][x])){\n                let index = walls.indexOf(grid[i][x])\n                walls.splice(index,1)\n            }\n        }else{\n            if(!grid[i][x].isStart && !grid[i][x].isEnd){\n                grid[i][x].isWall = true\n                walls.push(grid[i][x])\n            }\n        }\n    }\n}\nfunction randomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import React from \"react\";\nimport Node from \"./Node\";\nimport {dijkstra,getPath} from \"./Algorithms/dijkstra\"\nimport {AStar} from \"./Algorithms/AStar\"\nimport {DFS} from './Algorithms/dfs';\nimport {BFS,BFS1, Bidirectional} from './Algorithms/bfs';\nimport {GBS} from './Algorithms/gbs';\nimport {generateMazeRandomDFS} from './MazeAlgorithms/RandomDFS';\nimport { recursiveDivision } from \"./MazeAlgorithms/RecursiveDivision\";\nimport \"./grid.css\";\n\nlet STARTNODE_i = 10\nlet STARTNODE_j = 15\nlet ENDNODE_i = 10\nlet ENDNODE_j = 35\nconst WIDTH = 60\nconst HEIGHT = 30\n\nclass Visualizer extends React.Component{\n    constructor(){\n        super()\n        this.state = {\n            grid: [],\n            mousePressed:false,\n            startPicked:false,\n            endPicked: false,\n            message: \"Drag and drop Start and End nodes to change their position. Drag through the grid to create walls\",\n            showScores: false,\n            algoIsRunning: false\n        }\n    }\n    componentDidMount(){\n        const grid = getGrid(WIDTH,HEIGHT)\n        this.setState({grid: grid})\n    }\n\n    //Clears Animated nodes only <- Bugs\n    clearAnimation(){\n       // const grid = getGrid(WIDTH,HEIGHT)\n        for(let i = 0; i<this.state.grid.length; i++){\n            for(let j = 0; j < this.state.grid[0].length;j++){\n                if(!this.state.grid[i][j].isWall){\n                    this.setState({grid: makeNewNode(this.state.grid, i, j)})\n                    if(!this.state.grid[i][j].isStart && !this.state.grid[i][j].isEnd){\n                        document.getElementById(`node-${i}-${j}`).className = \"node\";\n                        document.getElementById(`node-${i}-${j}`).innerHTML = \"\";\n                    }\n                \n                }\n            }\n        } \n    }\n    clear(){\n        const grid = getGrid(WIDTH,HEIGHT)\n        for(let i = 0; i<this.state.grid.length; i++){\n            for(let j = 0; j < this.state.grid[0].length;j++){\n                if(!this.state.grid[i][j].isStart && !this.state.grid[i][j].isEnd){\n                    document.getElementById(`node-${i}-${j}`).className = \"node\";\n                    document.getElementById(`node-${i}-${j}`).innerHTML = \"\";\n                }\n            }\n        } \n        this.setState({grid: grid,message: \"Drag and drop Start and End nodes to change their position. Drag through the grid to create walls\"})      \n    }\n    //----------Clear\n\n    //Mouse Events For Wall, Start and End\n    handleMouseDown(i,j){\n        const node = this.state.grid[i][j]\n        if(!node.isEnd&&!node.isStart){\n            const ng = toggleWall(this.state.grid, i, j);\n            this.setState({grid:ng, mousePressed : true});\n        }\n    }\n    handleMouseEnter(i,j){\n        if(!this.state.mousePressed) return;\n        const node = this.state.grid[i][j]\n        if(this.state.startPicked){\n            if(!node.isWall){\n                STARTNODE_i = i\n                STARTNODE_j = j\n                const ng = makeStart(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n        }\n        else if(this.state.endPicked){\n            if(!node.isWall){\n                ENDNODE_i = i\n                ENDNODE_j = j\n                const ng = makeEnd(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n        }\n        else{\n            if(!this.state.grid[i][j].isStart&&!this.state.grid[i][j].isEnd){\n                const ng = toggleWall(this.state.grid, i, j);\n                this.setState({grid:ng});\n            }\n        }\n    }\n    handleMouseLeave(i,j){\n        if(!this.state.mousePressed) return;\n        if(this.state.startPicked){\n            const ng = removeStart(this.state.grid, i,j)\n            this.setState({grid: ng})\n        }\n        else if(this.state.endPicked){\n            const ng = removeEnd(this.state.grid, i,j)\n            this.setState({grid: ng})\n        }\n    }\n    handleMouseUp(i,j){\n        const node = this.state.grid[i][j]\n        if(this.state.startPicked){\n            STARTNODE_i = i\n            STARTNODE_j = j\n            const ng = makeStart(this.state.grid, i,j)\n            this.setState({grid: ng, startPicked: false,mousePressed : false})\n        }\n        else if(this.state.endPicked){\n            ENDNODE_i = i\n            ENDNODE_j = j\n            const ng = makeEnd(this.state.grid, i,j)\n            this.setState({grid: ng, endPicked : false,mousePressed : false})\n        }\n        else{\n            if(node.isStart){\n                this.setState({startPicked: true,mousePressed : true});\n                const ng = removeStart(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n            else if(node.isEnd){\n                this.setState({endPicked: true,mousePressed : true});\n                const ng = removeEnd(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n            else{\n                this.setState({startPicked: false, endPicked: false,mousePressed : false});\n            }\n        }\n    }\n\n    //------------------ Mouse Events\n\n    //Animation\n    animate(path, shortPath, showScore){\n        if(path===-1){this.setState({message:\"No Solution\"});\n        return;    \n    }\n        else{\n            for(let i = 0; i <= path.length; i++){\n                if (i===path.length){\n                    setTimeout(()=>{\n                        this.animateShortestPath(shortPath)\n                    }, 10*i)\n                    return;\n                }\n            setTimeout(()=>{\n                const node = path[i]\n                if(!node.isStart && !node.isEnd){\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n                if(showScore){\n                    document.getElementById(`node-${node.row}-${node.col}`).innerHTML = `<p class = \"score\">${node.f}</p>`;\n                }\n                }\n                }, 10*i);\n            }\n    }\n    }\n    animateShortestPath(path){\n        for(let i = 0; i < path.length; i++){\n            setTimeout(()=>{\n                const node = path[i]\n                if(!node.isStart && !node.isEnd){\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest\";\n                }\n                }, 10*i);\n            }\n            this.setState({message:\"Found the shortest path.\"})\n            setTimeout(()=>{\n                this.setState({message:\"Clear the grid\"})\n            }, 3000)\n            \n    }\n    //--------animation\n\n    // Dijkstra\n    visualizeDijkstra(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = dijkstra(grid,startNode, endNode)\n        const shortestPath = getPath(endNode)\n        this.animate(path, shortestPath, showScore);\n    }\n    //-----dijkstra\n    // A*\n    visualizeAStar(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = AStar(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, showScore);\n    }\n    //------a*\n    //DFS\n    visualizeDFS(){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = DFS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, false);\n    }\n    //-------DFS\n    //BFS\n    visualizeBFS(){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = BFS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, false);\n    }\n    //------BFS\n    //Greedy first search\n    visualizeGBS(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = GBS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path,shortestPath, showScore)\n    }\n\n    animateBidirectional(path1,path2, shortestPath1, shortestPath2){\n\n            for(let i = 0; i <= path1.length; i++){\n                if (i===path1.length){\n                    setTimeout(()=>{\n                        this.animateShortestPath(shortestPath1)\n                        this.animateShortestPath(shortestPath2)\n                    }, 10*i)\n                    return;\n                }\n            setTimeout(()=>{\n                const node1 = path1[i]\n                const node2 = path2[i]\n                    if(node1 && node2){\n                        if(!node1.isStart && !node1.isEnd && !node2.isStart && !node2.isEnd){\n                            document.getElementById(`node-${node1.row}-${node1.col}`).className = \"node node-visited\";\n                            document.getElementById(`node-${node2.row}-${node2.col}`).className = \"node node-visited\";\n                    }\n            }\n                }, 10*i);\n            }\n    }\n    visualizeBidirectional(){\n    //     this.setState({message:\"Searching...\", algoIsRunning:true})\n    //     let grid = this.state.grid\n    //     const startNode = grid[STARTNODE_i][STARTNODE_j]\n    //     const endNode = grid[ENDNODE_i][ENDNODE_j]\n    //     const path1 = BFS1(grid,startNode)\n    //     grid = getGrid(WIDTH,HEIGHT)\n    //     const path2 = BFS1(grid, endNode)\n    //     let intersection1 = null\n    //     let intersection2 = null\n    //     let found = false\n    //     let p = 0\n    //     let q = 0\n    //     while(!found&&p<path1.length&&path2.length>q){\n    //         let i = path1[p]\n    //         let j = path2[q]\n    //         if(i.col === j.col && i.row === j.row){\n    //             intersection1 = i\n    //             intersection2 = j\n    //             found = true\n    //         }\n    //         p++;\n    //         q++;\n    //     }\n    //     // for(let p = path1.length-1; p>=0; p--){\n    //     //     let i = path1[p]\n    //     //     for(let q = path2.length-1; q>=0; q--){\n    //     //         let j = path2[q]\n    //     //         if(i.col === j.col && i.row === j.row){\n    //     //             intersection1 = i\n    //     //             intersection2 = j\n    //     //             found = true\n    //     //             break\n    //     //         }\n    //     //     }\n    //     //     if(found){\n    //     //         break\n    //     //     }\n    //     // }\n    //     if(found){\n    //         const shortest1 = getPath(intersection1)\n    //         const shortest2 = getPath(intersection2)\n    //         const p1 = path1.splice(0,path1.indexOf(intersection1)+1)\n    //         const p2 = path2.splice(0,path2.indexOf(intersection2)+1)\n    //         console.log(p1,p2)\n    //         this.animateBidirectional(p1,p2,shortest1,shortest2)\n    //     }\n\n    return;\n        \n    }\n    visualizeRandomDFSMaze(){\n        this.setState({algoIsRunning:true})\n        this.clear()\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const walls = generateMazeRandomDFS(grid, startNode, endNode)\n        this.animateWalls(walls)\n    }\n    visualizeRecursiveDivision(){\n        this.setState({algoIsRunning:true})\n        this.clear()\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const walls = recursiveDivision(grid, startNode, endNode)\n        this.animateWalls(walls)\n    }\n    animateWalls(walls){\n        for(let i = 0; i<=walls.length;i++){  \n            if(i===walls.length){\n                setTimeout(()=>{\n                    const ng = makeWalls(this.state.grid,walls)\n                    this.setState({grid:ng})\n                },10*i)\n                return; \n            }\n            setTimeout(()=>{\n                if(walls[i]){\n                document.getElementById(`node-${walls[i].row}-${walls[i].col}`).className = \"node node-wall\";\n                }\n                },10*i)\n    }\n    }\n    render(){\n        const nodes = this.state.grid\n        return (<div className = \"main\">\n        <h6>{this.state.message}</h6>\n            <table className = \"grid\">\n            <tbody>\n            {nodes.map((row, rowId) => {\n                return <tr className = \"row\" key = {rowId}>\n                        {row.map((cell, cellId)=>{\n                            const {row, col, isEnd, isStart, isWall, isVisited} = cell;\n                            return <Node\n                                key = {cellId}\n                                col = {col}\n                                row = {row}\n                                isStart = {isStart}\n                                isEnd = {isEnd}\n                                isWall = {isWall}\n                                isVisited = {isVisited}\n                                onMouseDown = {(row,col)=>this.handleMouseDown(row,col)}\n                                onMouseEnter = {(row,col)=>this.handleMouseEnter(row,col)}\n                                onMouseUp = {(row,col)=>this.handleMouseUp(row,col)}\n                                onMouseLeave = {(row, col)=>this.handleMouseLeave(row,col)}>\n                                </Node>})}</tr>\n                        })}\n            </tbody>\n        </table>\n        </div>\n        )\n    }\n}\n\n// Helper Functions\nfunction getGrid(width, height) {\n    const grid = []\n    for(let i = 0; i<height; i++){\n        const row = []\n        for(let j = 0; j <width; j++){ \n            row.push(newNode(i,j))\n           }\n            grid.push(row)\n    }\n    return grid\n }\n\n function newNode(i,j) {\n     return{\n         row: i,\n         col: j,\n         isStart: i === STARTNODE_i && j === STARTNODE_j,\n         isEnd: i === ENDNODE_i && j === ENDNODE_j,\n         distance: Infinity,\n         previous: null,\n         isVisited: false,\n         isWall: false,\n         h:0,\n         g:0,\n         f:0\n     }\n }\n \nfunction makeNewNode(grid,i,j){\n    const ng = grid.slice();\n    const node = newNode(i,j);\n    ng[i][j] = node\n    return ng\n}\n\nfunction toggleWall(grid, i, j){\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isWall: !node.isWall,\n    }\n    ng[i][j] = n\n    return ng\n\n}\nfunction makeWalls(grid, walls){\n    const ng = grid.slice();\n        for(let w of walls){\n            const i = w.row\n            const j = w.col\n            ng[i][j] = w;\n        }\n    return ng\n\n}\n\nfunction makeStart(grid, i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isStart: true,\n        isWall: false\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction removeStart(grid,i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isStart: false,\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction makeEnd(grid, i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isEnd: true,\n        isWall: false\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction removeEnd(grid,i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isEnd: false,\n    }\n    ng[i][j] = n\n    return ng\n}\n\nexport default Visualizer","import React from \"react\";\nimport Visulalizer from \"./Visulalizer/Visualizer\";\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props){\n    super(props)\n    this.state = {\n      currentAlgo: \"Dijkstra\",\n      algoTypeWeighted:true,\n      showScores:false\n    }\n    this.child = React.createRef()\n  }\n  changeShowScores(){\n    this.setState(prevState=>{\n      return {\n        showScores: !prevState.showScores\n      }\n    })\n  }\n  chageAlgo(a){\n    this.setState({currentAlgo:a})\n    setTimeout(()=>{\n    console.log(this.state.currentAlgo)\n    const algo = this.state.currentAlgo\n    if(algo === \"Dijkstra\"){\n      this.setState({algoTypeWeighted:true})\n    }\n    if(algo === \"A*\"){\n      this.setState({algoTypeWeighted:true})\n        }\n    if(algo === \"DFS\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    if(algo === \"BFS\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    if(algo === \"GBS\"){\n      this.setState({algoTypeWeighted:true})\n        }\n    if(algo === \"Bidirectional\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    },100)\n  }\n  clear(e){\n    e.preventDefault()\n    this.child.current.clear(e)\n  }\n  clearPath(e){\n    e.preventDefault()\n    this.child.current.clearAnimation(e)\n  }\n  Visualize(e, showScore){\n    e.preventDefault()\n    const algo = this.state.currentAlgo\n    console.log(algo)\n    if(algo === \"Dijkstra\"){\n      this.child.current.visualizeDijkstra(showScore)\n    }\n    if(algo === \"A*\"){\n      this.child.current.visualizeAStar(showScore)\n    }\n    if(algo === \"DFS\"){\n      this.child.current.visualizeDFS()\n    }\n    if(algo === \"BFS\"){\n      this.child.current.visualizeBFS()\n    }\n    if(algo === \"GBS\"){\n      this.child.current.visualizeGBS(showScore)\n    }\n    if(algo === \"Bidirectional\"){\n      this.child.current.visualizeBidirectional()\n        }\n  }\n  createMaze(maze){\n    if(maze === \"RDFS\"){\n      this.child.current.visualizeRandomDFSMaze()\n    }\n    if(maze === \"RDM\"){\n      this.child.current.visualizeRecursiveDivision()\n    }\n  }\n  render(){\n  return (\n    <div className=\"App\">\n      <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\n      <img src=\"./logo.png\" width=\"30\" height=\"30\" style = {{marginRight:\"10px\"}} alt=\"\"></img>\n      <a className=\"navbar-brand\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      {/* <a className=\"navbar-brand\" href=\"#\">Algorithm Visualizer</a> */}\n      <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n      <ul className=\"navbar-nav mr-auto\">\n      {/* <li className=\"nav-item active\">\n      <a className=\"nav-link\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      </li> */}\n      \n      {/* <li className=\"nav-item\">\n        <a className=\"nav-link\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      </li> */}\n      <li className=\"nav-item dropdown\">\n        <a className=\"nav-link dropdown-toggle\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n          {this.state.currentAlgo}\n        </a>\n        <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"Dijkstra\")}>Dijkstra</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"A*\")}>A*</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"GBS\")}>Greedy Best Search</a>\n          <div className=\"dropdown-divider\">Unweighted</div>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"BFS\")}>Breadth First Search</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"Bidirectional\")}>Bidirectional</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"DFS\")}>Depth First Search</a> \n        </div>\n        \n      </li>\n      <li className=\"nav-item dropdown\">\n        <a className=\"nav-link dropdown-toggle\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n          Create Maze\n        </a>\n        <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n          <a className=\"dropdown-item\" onClick={()=>this.createMaze(\"RDFS\")}>Random Depth First Search</a>\n          <a className=\"dropdown-item\" onClick={()=>this.createMaze(\"RDM\")}>Recursive Division</a>\n        </div>  \n      </li>\n      <li className = \"nav-item\">\n      <div className=\"btn-toolbar\" role=\"toolbar\" aria-label=\"Toolbar with button groups\">\n      <div style= {{marginTop:\"7px\",marginLeft:\"20px\",fontSize:\"15px\"}}>Show Scores:</div>\n      <div style= {{marginTop:\"3px\", border:\"1px solid gray\", borderRadius:\"5px\"}} className=\"btn-group btn-group-sm\" role=\"group\" aria-label=\"First group\">\n      <button \n        type=\"button\" \n        className={this.state.showScores ? \"btn btn-dark\" : \"btn btn-light\"}\n        onClick={()=>this.changeShowScores()}\n        disabled = {this.state.algoTypeWeighted && !this.state.showScores ? false : true}>\n        Yes</button>\n      <button \n        type=\"button\" \n        className={this.state.showScores ? \"btn btn-light\" : \"btn btn-dark\"}\n        onClick={()=>this.changeShowScores()}\n        disabled = {this.state.algoTypeWeighted && this.state.showScores ? false : true}>\n        No</button>\n    </div>\n    \n  </div>\n      \n      </li>\n      </ul>\n      <form className=\"form-inline my-2 my-lg-0\">\n      <div className=\"btn-group btn-group-md\" role=\"group\" aria-label=\"First group\">\n        <button className=\"btn btn-warning my-2 my-sm-0\" onClick= {(e)=>this.clearPath(e)}>Clear Path</button>\n        <button className=\"btn btn-danger my-2 my-sm-0\" onClick= {(e)=>this.clear(e)}>Clear Grid</button>\n        <button className=\"btn btn-success sm\" onClick= {(e)=>this.Visualize(e, this.state.showScores)}>Visualize {this.state.currentAlgo}</button>\n      </div>\n      </form>\n      </div>\n      </nav>\n      <Visulalizer\n      ref = {this.child} \n      currentAlgo = {this.state.currentAlgo}\n      ></Visulalizer>\n    </div>\n  );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}