[{"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/index.js":"1","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/reportWebVitals.js":"2","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/App.js":"3","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Visualizer.js":"4","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Node.js":"5","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/dijkstra.js":"6","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/AStar.js":"7","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/dfs.js":"8","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/bfs.js":"9","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/gbs.js":"10","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/MazeAlgorithms/RandomDFS.js":"11","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/MazeAlgorithms/RecursiveDivision.js":"12"},{"size":457,"mtime":1607697232354,"results":"13","hashOfConfig":"14"},{"size":362,"mtime":1607676521735,"results":"15","hashOfConfig":"14"},{"size":6104,"mtime":1608184067632,"results":"16","hashOfConfig":"14"},{"size":15978,"mtime":1608187621287,"results":"17","hashOfConfig":"14"},{"size":765,"mtime":1608181114814,"results":"18","hashOfConfig":"14"},{"size":1721,"mtime":1608035956817,"results":"19","hashOfConfig":"14"},{"size":2126,"mtime":1607882372569,"results":"20","hashOfConfig":"14"},{"size":998,"mtime":1607938463164,"results":"21","hashOfConfig":"14"},{"size":2063,"mtime":1608183960514,"results":"22","hashOfConfig":"14"},{"size":1265,"mtime":1607869101652,"results":"23","hashOfConfig":"14"},{"size":1866,"mtime":1608048239868,"results":"24","hashOfConfig":"14"},{"size":2744,"mtime":1608039246857,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"lu4nte",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"28"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/index.js",[],["55","56"],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/reportWebVitals.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/App.js",["57","58","59","60","61","62","63","64","65","66"],"import React from \"react\";\nimport Visulalizer from \"./Visulalizer/Visualizer\";\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props){\n    super(props)\n    this.state = {\n      currentAlgo: \"Dijkstra\",\n      algoTypeWeighted:true,\n      showScores:false\n    }\n    this.child = React.createRef()\n  }\n  changeShowScores(){\n    this.setState(prevState=>{\n      return {\n        showScores: !prevState.showScores\n      }\n    })\n  }\n  chageAlgo(a){\n    this.setState({currentAlgo:a})\n    setTimeout(()=>{\n    console.log(this.state.currentAlgo)\n    const algo = this.state.currentAlgo\n    if(algo === \"Dijkstra\"){\n      this.setState({algoTypeWeighted:true})\n    }\n    if(algo === \"A*\"){\n      this.setState({algoTypeWeighted:true})\n        }\n    if(algo === \"DFS\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    if(algo === \"BFS\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    if(algo === \"GBS\"){\n      this.setState({algoTypeWeighted:true})\n        }\n    if(algo === \"Bidirectional\"){\n      this.setState({algoTypeWeighted:false})\n        }\n    },100)\n  }\n  clear(e){\n    e.preventDefault()\n    this.child.current.clear(e)\n  }\n  clearPath(e){\n    e.preventDefault()\n    this.child.current.clearAnimation(e)\n  }\n  Visualize(e, showScore){\n    e.preventDefault()\n    const algo = this.state.currentAlgo\n    console.log(algo)\n    if(algo === \"Dijkstra\"){\n      this.child.current.visualizeDijkstra(showScore)\n    }\n    if(algo === \"A*\"){\n      this.child.current.visualizeAStar(showScore)\n    }\n    if(algo === \"DFS\"){\n      this.child.current.visualizeDFS()\n    }\n    if(algo === \"BFS\"){\n      this.child.current.visualizeBFS()\n    }\n    if(algo === \"GBS\"){\n      this.child.current.visualizeGBS(showScore)\n    }\n    if(algo === \"Bidirectional\"){\n      this.child.current.visualizeBidirectional()\n        }\n  }\n  createMaze(maze){\n    if(maze === \"RDFS\"){\n      this.child.current.visualizeRandomDFSMaze()\n    }\n    if(maze === \"RDM\"){\n      this.child.current.visualizeRecursiveDivision()\n    }\n  }\n  render(){\n  return (\n    <div className=\"App\">\n      <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\n      <img src=\"./logo.png\" width=\"30\" height=\"30\" style = {{marginRight:\"10px\"}} alt=\"\"></img>\n      <a className=\"navbar-brand\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      {/* <a className=\"navbar-brand\" href=\"#\">Algorithm Visualizer</a> */}\n      <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n      <ul className=\"navbar-nav mr-auto\">\n      {/* <li className=\"nav-item active\">\n      <a className=\"nav-link\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      </li> */}\n      \n      {/* <li className=\"nav-item\">\n        <a className=\"nav-link\" href=\"https://github.com/JaivalBhup/AlgorithmVisualizer-React\">GitHub Repo</a>\n      </li> */}\n      <li className=\"nav-item dropdown\">\n        <a className=\"nav-link dropdown-toggle\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n          {this.state.currentAlgo}\n        </a>\n        <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"Dijkstra\")}>Dijkstra</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"A*\")}>A*</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"GBS\")}>Greedy Best Search</a>\n          <div className=\"dropdown-divider\">Unweighted</div>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"BFS\")}>Breadth First Search</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"Bidirectional\")}>Bidirectional</a>\n          <a className=\"dropdown-item\" onClick={()=>this.chageAlgo(\"DFS\")}>Depth First Search</a> \n        </div>\n        \n      </li>\n      <li className=\"nav-item dropdown\">\n        <a className=\"nav-link dropdown-toggle\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n          Create Maze\n        </a>\n        <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n          <a className=\"dropdown-item\" onClick={()=>this.createMaze(\"RDFS\")}>Random Depth First Search</a>\n          <a className=\"dropdown-item\" onClick={()=>this.createMaze(\"RDM\")}>Recursive Division</a>\n        </div>  \n      </li>\n      <li className = \"nav-item\">\n      <div className=\"btn-toolbar\" role=\"toolbar\" aria-label=\"Toolbar with button groups\">\n      <div style= {{marginTop:\"7px\",marginLeft:\"20px\",fontSize:\"15px\"}}>Show Scores:</div>\n      <div style= {{marginTop:\"3px\", border:\"1px solid gray\", borderRadius:\"5px\"}} className=\"btn-group btn-group-sm\" role=\"group\" aria-label=\"First group\">\n      <button \n        type=\"button\" \n        className={this.state.showScores ? \"btn btn-dark\" : \"btn btn-light\"}\n        onClick={()=>this.changeShowScores()}\n        disabled = {this.state.algoTypeWeighted && !this.state.showScores ? false : true}>\n        Yes</button>\n      <button \n        type=\"button\" \n        className={this.state.showScores ? \"btn btn-light\" : \"btn btn-dark\"}\n        onClick={()=>this.changeShowScores()}\n        disabled = {this.state.algoTypeWeighted && this.state.showScores ? false : true}>\n        No</button>\n    </div>\n    \n  </div>\n      \n      </li>\n      </ul>\n      <form className=\"form-inline my-2 my-lg-0\">\n      <div className=\"btn-group btn-group-md\" role=\"group\" aria-label=\"First group\">\n        <button className=\"btn btn-warning my-2 my-sm-0\" onClick= {(e)=>this.clearPath(e)}>Clear Path</button>\n        <button className=\"btn btn-danger my-2 my-sm-0\" onClick= {(e)=>this.clear(e)}>Clear Grid</button>\n        <button className=\"btn btn-success sm\" onClick= {(e)=>this.Visualize(e, this.state.showScores)}>Visualize {this.state.currentAlgo}</button>\n      </div>\n      </form>\n      </div>\n      </nav>\n      <Visulalizer\n      ref = {this.child} \n      currentAlgo = {this.state.currentAlgo}\n      ></Visulalizer>\n    </div>\n  );\n  }\n}\n\nexport default App;\n","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Visualizer.js",["67","68"],"import React from \"react\";\nimport Node from \"./Node\";\nimport {dijkstra,getPath} from \"./Algorithms/dijkstra\"\nimport {AStar} from \"./Algorithms/AStar\"\nimport {DFS} from './Algorithms/dfs';\nimport {BFS,BFS1, Bidirectional} from './Algorithms/bfs';\nimport {GBS} from './Algorithms/gbs';\nimport {generateMazeRandomDFS} from './MazeAlgorithms/RandomDFS';\nimport { recursiveDivision } from \"./MazeAlgorithms/RecursiveDivision\";\nimport \"./grid.css\";\n\nlet STARTNODE_i = 10\nlet STARTNODE_j = 15\nlet ENDNODE_i = 10\nlet ENDNODE_j = 35\nconst WIDTH = 60\nconst HEIGHT = 30\n\nclass Visualizer extends React.Component{\n    constructor(){\n        super()\n        this.state = {\n            grid: [],\n            mousePressed:false,\n            startPicked:false,\n            endPicked: false,\n            message: \"Drag and drop Start and End nodes to change their position. Drag through the grid to create walls\",\n            showScores: false,\n            algoIsRunning: false\n        }\n    }\n    componentDidMount(){\n        const grid = getGrid(WIDTH,HEIGHT)\n        this.setState({grid: grid})\n    }\n\n    //Clears Animated nodes only <- Bugs\n    clearAnimation(){\n       // const grid = getGrid(WIDTH,HEIGHT)\n        for(let i = 0; i<this.state.grid.length; i++){\n            for(let j = 0; j < this.state.grid[0].length;j++){\n                if(!this.state.grid[i][j].isWall){\n                    this.setState({grid: makeNewNode(this.state.grid, i, j)})\n                    if(!this.state.grid[i][j].isStart && !this.state.grid[i][j].isEnd){\n                        document.getElementById(`node-${i}-${j}`).className = \"node\";\n                        document.getElementById(`node-${i}-${j}`).innerHTML = \"\";\n                    }\n                \n                }\n            }\n        } \n    }\n    clear(){\n        const grid = getGrid(WIDTH,HEIGHT)\n        for(let i = 0; i<this.state.grid.length; i++){\n            for(let j = 0; j < this.state.grid[0].length;j++){\n                if(!this.state.grid[i][j].isStart && !this.state.grid[i][j].isEnd){\n                    document.getElementById(`node-${i}-${j}`).className = \"node\";\n                    document.getElementById(`node-${i}-${j}`).innerHTML = \"\";\n                }\n            }\n        } \n        this.setState({grid: grid,message: \"Drag and drop Start and End nodes to change their position. Drag through the grid to create walls\"})      \n    }\n    //----------Clear\n\n    //Mouse Events For Wall, Start and End\n    handleMouseDown(i,j){\n        const node = this.state.grid[i][j]\n        if(!node.isEnd&&!node.isStart){\n            const ng = toggleWall(this.state.grid, i, j);\n            this.setState({grid:ng, mousePressed : true});\n        }\n    }\n    handleMouseEnter(i,j){\n        if(!this.state.mousePressed) return;\n        const node = this.state.grid[i][j]\n        if(this.state.startPicked){\n            if(!node.isWall){\n                STARTNODE_i = i\n                STARTNODE_j = j\n                const ng = makeStart(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n        }\n        else if(this.state.endPicked){\n            if(!node.isWall){\n                ENDNODE_i = i\n                ENDNODE_j = j\n                const ng = makeEnd(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n        }\n        else{\n            if(!this.state.grid[i][j].isStart&&!this.state.grid[i][j].isEnd){\n                const ng = toggleWall(this.state.grid, i, j);\n                this.setState({grid:ng});\n            }\n        }\n    }\n    handleMouseLeave(i,j){\n        if(!this.state.mousePressed) return;\n        if(this.state.startPicked){\n            const ng = removeStart(this.state.grid, i,j)\n            this.setState({grid: ng})\n        }\n        else if(this.state.endPicked){\n            const ng = removeEnd(this.state.grid, i,j)\n            this.setState({grid: ng})\n        }\n    }\n    handleMouseUp(i,j){\n        const node = this.state.grid[i][j]\n        if(this.state.startPicked){\n            STARTNODE_i = i\n            STARTNODE_j = j\n            const ng = makeStart(this.state.grid, i,j)\n            this.setState({grid: ng, startPicked: false,mousePressed : false})\n        }\n        else if(this.state.endPicked){\n            ENDNODE_i = i\n            ENDNODE_j = j\n            const ng = makeEnd(this.state.grid, i,j)\n            this.setState({grid: ng, endPicked : false,mousePressed : false})\n        }\n        else{\n            if(node.isStart){\n                this.setState({startPicked: true,mousePressed : true});\n                const ng = removeStart(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n            else if(node.isEnd){\n                this.setState({endPicked: true,mousePressed : true});\n                const ng = removeEnd(this.state.grid, i,j)\n                this.setState({grid: ng})\n            }\n            else{\n                this.setState({startPicked: false, endPicked: false,mousePressed : false});\n            }\n        }\n    }\n\n    //------------------ Mouse Events\n\n    //Animation\n    animate(path, shortPath, showScore){\n        if(path===-1){this.setState({message:\"No Solution\"});\n        return;    \n    }\n        else{\n            for(let i = 0; i <= path.length; i++){\n                if (i===path.length){\n                    setTimeout(()=>{\n                        this.animateShortestPath(shortPath)\n                    }, 10*i)\n                    return;\n                }\n            setTimeout(()=>{\n                const node = path[i]\n                if(!node.isStart && !node.isEnd){\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n                if(showScore){\n                    document.getElementById(`node-${node.row}-${node.col}`).innerHTML = `<p class = \"score\">${node.f}</p>`;\n                }\n                }\n                }, 10*i);\n            }\n    }\n    }\n    animateShortestPath(path){\n        for(let i = 0; i < path.length; i++){\n            setTimeout(()=>{\n                const node = path[i]\n                if(!node.isStart && !node.isEnd){\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest\";\n                }\n                }, 10*i);\n            }\n            this.setState({message:\"Found the shortest path.\"})\n            setTimeout(()=>{\n                this.setState({message:\"Clear the grid\"})\n            }, 3000)\n            \n    }\n    //--------animation\n\n    // Dijkstra\n    visualizeDijkstra(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = dijkstra(grid,startNode, endNode)\n        const shortestPath = getPath(endNode)\n        this.animate(path, shortestPath, showScore);\n    }\n    //-----dijkstra\n    // A*\n    visualizeAStar(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = AStar(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, showScore);\n    }\n    //------a*\n    //DFS\n    visualizeDFS(){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = DFS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, false);\n    }\n    //-------DFS\n    //BFS\n    visualizeBFS(){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = BFS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path, shortestPath, false);\n    }\n    //------BFS\n    //Greedy first search\n    visualizeGBS(showScore){\n        this.setState({message:\"Searching...\", algoIsRunning:true})\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const path = GBS(grid,startNode, endNode)\n        const shortestPath = getPath(endNode);\n        this.animate(path,shortestPath, showScore)\n    }\n\n    animateBidirectional(path1,path2, shortestPath1, shortestPath2){\n\n            for(let i = 0; i <= path1.length; i++){\n                if (i===path1.length){\n                    setTimeout(()=>{\n                        this.animateShortestPath(shortestPath1)\n                        this.animateShortestPath(shortestPath2)\n                    }, 10*i)\n                    return;\n                }\n            setTimeout(()=>{\n                const node1 = path1[i]\n                const node2 = path2[i]\n                    if(node1 && node2){\n                        if(!node1.isStart && !node1.isEnd && !node2.isStart && !node2.isEnd){\n                            document.getElementById(`node-${node1.row}-${node1.col}`).className = \"node node-visited\";\n                            document.getElementById(`node-${node2.row}-${node2.col}`).className = \"node node-visited\";\n                    }\n            }\n                }, 10*i);\n            }\n    }\n    visualizeBidirectional(){\n    //     this.setState({message:\"Searching...\", algoIsRunning:true})\n    //     let grid = this.state.grid\n    //     const startNode = grid[STARTNODE_i][STARTNODE_j]\n    //     const endNode = grid[ENDNODE_i][ENDNODE_j]\n    //     const path1 = BFS1(grid,startNode)\n    //     grid = getGrid(WIDTH,HEIGHT)\n    //     const path2 = BFS1(grid, endNode)\n    //     let intersection1 = null\n    //     let intersection2 = null\n    //     let found = false\n    //     let p = 0\n    //     let q = 0\n    //     while(!found&&p<path1.length&&path2.length>q){\n    //         let i = path1[p]\n    //         let j = path2[q]\n    //         if(i.col === j.col && i.row === j.row){\n    //             intersection1 = i\n    //             intersection2 = j\n    //             found = true\n    //         }\n    //         p++;\n    //         q++;\n    //     }\n    //     // for(let p = path1.length-1; p>=0; p--){\n    //     //     let i = path1[p]\n    //     //     for(let q = path2.length-1; q>=0; q--){\n    //     //         let j = path2[q]\n    //     //         if(i.col === j.col && i.row === j.row){\n    //     //             intersection1 = i\n    //     //             intersection2 = j\n    //     //             found = true\n    //     //             break\n    //     //         }\n    //     //     }\n    //     //     if(found){\n    //     //         break\n    //     //     }\n    //     // }\n    //     if(found){\n    //         const shortest1 = getPath(intersection1)\n    //         const shortest2 = getPath(intersection2)\n    //         const p1 = path1.splice(0,path1.indexOf(intersection1)+1)\n    //         const p2 = path2.splice(0,path2.indexOf(intersection2)+1)\n    //         console.log(p1,p2)\n    //         this.animateBidirectional(p1,p2,shortest1,shortest2)\n    //     }\n\n    return;\n        \n    }\n    visualizeRandomDFSMaze(){\n        this.setState({algoIsRunning:true})\n        this.clear()\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const walls = generateMazeRandomDFS(grid, startNode, endNode)\n        this.animateWalls(walls)\n    }\n    visualizeRecursiveDivision(){\n        this.setState({algoIsRunning:true})\n        this.clear()\n        const grid = this.state.grid\n        const startNode = grid[STARTNODE_i][STARTNODE_j]\n        const endNode = grid[ENDNODE_i][ENDNODE_j]\n        const walls = recursiveDivision(grid, startNode, endNode)\n        this.animateWalls(walls)\n    }\n    animateWalls(walls){\n        for(let i = 0; i<=walls.length;i++){  \n            if(i===walls.length){\n                setTimeout(()=>{\n                    const ng = makeWalls(this.state.grid,walls)\n                    this.setState({grid:ng})\n                },10*i)\n                return; \n            }\n            setTimeout(()=>{\n                if(walls[i]){\n                document.getElementById(`node-${walls[i].row}-${walls[i].col}`).className = \"node node-wall\";\n                }\n                },10*i)\n    }\n    }\n    render(){\n        const nodes = this.state.grid\n        return (<div className = \"main\">\n        <h6>{this.state.message}</h6>\n            <table className = \"grid\">\n            <tbody>\n            {nodes.map((row, rowId) => {\n                return <tr className = \"row\" key = {rowId}>\n                        {row.map((cell, cellId)=>{\n                            const {row, col, isEnd, isStart, isWall, isVisited} = cell;\n                            return <Node\n                                key = {cellId}\n                                col = {col}\n                                row = {row}\n                                isStart = {isStart}\n                                isEnd = {isEnd}\n                                isWall = {isWall}\n                                isVisited = {isVisited}\n                                onMouseDown = {(row,col)=>this.handleMouseDown(row,col)}\n                                onMouseEnter = {(row,col)=>this.handleMouseEnter(row,col)}\n                                onMouseUp = {(row,col)=>this.handleMouseUp(row,col)}\n                                onMouseLeave = {(row, col)=>this.handleMouseLeave(row,col)}>\n                                </Node>})}</tr>\n                        })}\n            </tbody>\n        </table>\n        </div>\n        )\n    }\n}\n\n// Helper Functions\nfunction getGrid(width, height) {\n    const grid = []\n    for(let i = 0; i<height; i++){\n        const row = []\n        for(let j = 0; j <width; j++){ \n            row.push(newNode(i,j))\n           }\n            grid.push(row)\n    }\n    return grid\n }\n\n function newNode(i,j) {\n     return{\n         row: i,\n         col: j,\n         isStart: i === STARTNODE_i && j === STARTNODE_j,\n         isEnd: i === ENDNODE_i && j === ENDNODE_j,\n         distance: Infinity,\n         previous: null,\n         isVisited: false,\n         isWall: false,\n         h:0,\n         g:0,\n         f:0\n     }\n }\n \nfunction makeNewNode(grid,i,j){\n    const ng = grid.slice();\n    const node = newNode(i,j);\n    ng[i][j] = node\n    return ng\n}\n\nfunction toggleWall(grid, i, j){\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isWall: !node.isWall,\n    }\n    ng[i][j] = n\n    return ng\n\n}\nfunction makeWalls(grid, walls){\n    const ng = grid.slice();\n        for(let w of walls){\n            const i = w.row\n            const j = w.col\n            ng[i][j] = w;\n        }\n    return ng\n\n}\n\nfunction makeStart(grid, i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isStart: true,\n        isWall: false\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction removeStart(grid,i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isStart: false,\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction makeEnd(grid, i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isEnd: true,\n        isWall: false\n    }\n    ng[i][j] = n\n    return ng\n}\nfunction removeEnd(grid,i,j) {\n    const ng = grid.slice();\n    const node = ng[i][j];\n    \n    const n = {\n        ...node,\n        isEnd: false,\n    }\n    ng[i][j] = n\n    return ng\n}\n\nexport default Visualizer","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Node.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/dijkstra.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/AStar.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/dfs.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/bfs.js",["69"],"function traverse(grid, startNode) {\n    const queue = []\n    const visited = []\n    startNode.isVisited = true\n    queue.push(startNode)\n    while(queue.length>0){\n        const current = queue.shift()\n        visited.push(current)\n        const neighbours = getNeighbours(current, grid)\n        for(let n of neighbours){\n            if(!n.isVisited && !n.isWall){\n                queue.push(n)\n                n.previous = current\n                n.isVisited = true\n            }\n        }\n    }\n    return visited\n}\n\nexport function BFS(grid, startNode, endNode) {\n    const nodes = traverse(grid, startNode)\n    const t = []\n    for(let n of nodes){\n        if(n===endNode){return t}\n        t.push(n)\n    }\n    return -1\n}\nexport function BFS1(grid, startNode) {\n    const nodes = traverse(grid, startNode)\n    if(nodes) return nodes;\n    return -1\n}\n\nexport function Bidirectional(grid, startNode, endNode) {\n    const grid1 = grid.slice()\n    const grid2 = grid.slice()\n    const forward = traverse(grid1, startNode)\n    const backward = traverse(grid2, endNode)\n    console.log(backward)\n    // console.log(forward)\n    // console.log(backward)\n    // let intersection = []\n    // for(let f of forward){\n    //     backward.slice().reverse().forEach((b)=>{\n    //         if(f.row === b.row && f.col === b.col){\n    //             intersection[0] = f\n    //             intersection[1] = b\n    //             const path1 = forward.splice(0, forward.indexOf(intersection[0]))\n    //             const path2 = backward.splice(0, backward.indexOf(intersection[1]))\n    //             return [path1, path2, intersection]\n    //         }\n    //     })\n    // }\n    return -1\n}\n\nfunction getNeighbours(node, grid) {\n    const neighbours = [];\n    const {row, col} = node;\n    if(row>0)neighbours.push(grid[row-1][col]);\n    if(row<grid.length-1)neighbours.push(grid[row+1][col]);\n    if(col>0)neighbours.push(grid[row][col-1]);\n    if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);\n\n    return (neighbours.filter(neighbour => !neighbour.isVisited));\n}","/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/Algorithms/gbs.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/MazeAlgorithms/RandomDFS.js",[],"/Users/jaivalbhuptani/Desktop/algorithm_visualizer/src/Visulalizer/MazeAlgorithms/RecursiveDivision.js",[],["70","71"],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":103,"column":9,"nodeType":"78","endLine":103,"endColumn":149},{"ruleId":"76","severity":1,"message":"77","line":107,"column":11,"nodeType":"78","endLine":107,"endColumn":81},{"ruleId":"76","severity":1,"message":"77","line":108,"column":11,"nodeType":"78","endLine":108,"endColumn":75},{"ruleId":"76","severity":1,"message":"77","line":109,"column":11,"nodeType":"78","endLine":109,"endColumn":76},{"ruleId":"76","severity":1,"message":"77","line":111,"column":11,"nodeType":"78","endLine":111,"endColumn":76},{"ruleId":"76","severity":1,"message":"77","line":112,"column":11,"nodeType":"78","endLine":112,"endColumn":86},{"ruleId":"76","severity":1,"message":"77","line":113,"column":11,"nodeType":"78","endLine":113,"endColumn":76},{"ruleId":"76","severity":1,"message":"77","line":118,"column":9,"nodeType":"78","endLine":118,"endColumn":149},{"ruleId":"76","severity":1,"message":"77","line":122,"column":11,"nodeType":"78","endLine":122,"endColumn":78},{"ruleId":"76","severity":1,"message":"77","line":123,"column":11,"nodeType":"78","endLine":123,"endColumn":77},{"ruleId":"79","severity":1,"message":"80","line":6,"column":13,"nodeType":"81","messageId":"82","endLine":6,"endColumn":17},{"ruleId":"79","severity":1,"message":"83","line":6,"column":19,"nodeType":"81","messageId":"82","endLine":6,"endColumn":32},{"ruleId":"79","severity":1,"message":"84","line":39,"column":11,"nodeType":"81","messageId":"82","endLine":39,"endColumn":18},{"ruleId":"72","replacedBy":"85"},{"ruleId":"74","replacedBy":"86"},"no-native-reassign",["87"],"no-negated-in-lhs",["88"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-unused-vars","'BFS1' is defined but never used.","Identifier","unusedVar","'Bidirectional' is defined but never used.","'forward' is assigned a value but never used.",["87"],["88"],"no-global-assign","no-unsafe-negation"]